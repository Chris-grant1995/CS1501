documentation.txt 

So for my project, I made a number of decisions that were aimed at minimizing the overall amount of memory usage rather than minimizing runtime. I made this decision based on the real world application of this project, as it is more important to be able to store the entire list of cars rather than accessing them quickly. For this reason, I created the PQCar class which is what actually gets stored in the priority queue. This class consists of only two integers, the value that gets sorted into the priority queue (in this case, either miles or price) and an integer that represents the entire carâ€™s position in the arraylist of cars. I did this to minimize copies of car objects, not only to make it easier to update and remove the cars, but also to save on memory usage. I chose to use an arraylist over a regular array to store the cars as it is easier to insert and remove cars and there is no need to worry about manually increasing the size of the array. For my priority queue class, I initially was confused about how the implementation provided by the book was working, so I found an implementation provided by Duke University that I understood better, and when I asked the professor if there was any limitations on what we could use for the project, he indicated that this was fine. I then modified the implementation to suit my needs better. (The original file can be found here: https://www.cs.duke.edu/csed/poop/huff/spring05/code/PriorityQueue.java) Another implementation concern that I ran into when I was working on this project was how was I going to handle finding specific cars in my queues when dealing with removing, updating either the price or mileage, or finding a specific car based on make and model. I went with a KISS (Keep it simple, stupid) approach here again thinking about the real world application. You would rather have a slower system that works perfectly every time than a system that works slightly faster that could potentially have bugs in it due to a complex implementation. So with updating, removing and finding based on make and model, the system is relatively the same, PQCars get popped off the top of the queue and onto a Stack, until the car you want is found, then the specific operation is preformed (updating values, removing the car etc) and then the Stack of PQCars gets reinserted into the Queue, and it is updated as appropriate. Although this is not the most efficient way to do these operations, in a real world scenario, it will be good enough due to the fact that there will not be some crazy number of cars entered into the system, and it will be quick enough. 
  